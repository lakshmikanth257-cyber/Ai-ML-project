# CLAUDE.md

AI developer guidance for the Asyaüé≠ project.

## Project Overview

Asyaüé≠ is an async actor-based framework for deploying AI workloads on Kubernetes using:
- **CRD-based operator** for declarative actor deployment
- **Sidecar pattern** (Go) for message routing with pluggable transports
- **KEDA autoscaling** for event-driven, scale-to-zero workloads
- **MCP gateway** (optional) for envelope tracking and API integration

## Quick Reference

### Prerequisites
- **uv** (required for Python): `curl -LsSf https://astral.sh/uv/install.sh | sh`
- Go 1.24+, Python 3.7+ (asya-runtime), Python 3.13+ (other components), Docker, Make

### Essential Commands
```bash
make build              # Build all components
make test-unit          # Unit tests (Go + Python)
make test-component     # Component tests (single component + lightweight mocks)
make test-integration   # Integration tests (requires Docker)
make test-e2e           # End-to-end tests (requires Kind cluster)
make test               # Run all unit + integration tests
make lint               # Run linters with auto-fix
make cov                # Run all tests with coverage
```

Try to use `make <target>` instead of direct commands whenever possible. Add new Makefile targets for repeated tasks.

## Repository Structure

```
asya/
‚îú‚îÄ‚îÄ src/                     # Framework components (Go/Python)
‚îÇ   ‚îú‚îÄ‚îÄ asya-gateway/        # MCP gateway
‚îÇ   ‚îú‚îÄ‚îÄ asya-sidecar/        # Actor sidecar
‚îÇ   ‚îú‚îÄ‚îÄ asya-runtime/        # Actor runtime base (Python)
‚îÇ   ‚îú‚îÄ‚îÄ asya-crew/           # System actors with reserved roles
‚îÇ   ‚îú‚îÄ‚îÄ asya-operator/       # Kubernetes operator source
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ config/crd/      # AsyncActor CRD (generated by Kubebuilder)
‚îÇ   ‚îú‚îÄ‚îÄ asya-testing/        # Testing fixtures, utilities and shared test code
‚îÇ   ‚îî‚îÄ‚îÄ asya-cli/            # CLI tools for debugging and operating
‚îú‚îÄ‚îÄ deploy/helm-charts/      # Helm charts
‚îÇ   ‚îú‚îÄ‚îÄ asya-actor/          # Generic actor Helm chart
‚îÇ   ‚îú‚îÄ‚îÄ asya-crew/           # Crew actors Helm chart
‚îÇ   ‚îú‚îÄ‚îÄ asya-operator/       # Operator Helm chart
‚îÇ   ‚îî‚îÄ‚îÄ asya-gateway/        # Gateway Helm chart
‚îú‚îÄ‚îÄ testing/                 # Test suites (all except unit tests that are in src/)
‚îÇ   ‚îú‚îÄ‚îÄ component/           # Component tests (single component tests without mocks in docker compose)
‚îÇ   ‚îú‚îÄ‚îÄ integration/         # Integration tests (multi-component tests in docker compose)
‚îÇ   ‚îú‚îÄ‚îÄ e2e/                 # End-to-end tests (Kind cluster)
‚îÇ   ‚îî‚îÄ‚îÄ shared/              # Shared test utilities (mostly for docker compose configurations)
‚îî‚îÄ‚îÄ examples/                # Example AsyncActor CRDs
    ‚îî‚îÄ‚îÄ asyas/               # AsyncActor deployment examples
```

## Component Overview

All components are in `src/`. See [docs/architecture/](docs/architecture/) for detailed documentation.

### asya-gateway (Go)
MCP gateway with JSON-RPC 2.0, envelope tracking, and SSE streaming. Tools configurable via YAML (`src/asya-gateway/config/README.md`). Optional component for API integration.

### asya-sidecar (Go)
Envelope router injected into actor pods. Consumes from RabbitMQ/SQS, forwards to runtime via Unix socket, routes responses. Pluggable transport layer.

**Envelope Flow**: Queue ‚Üí Sidecar ‚Üí Runtime (Unix socket) ‚Üí Sidecar ‚Üí Next Queue

### asya-runtime (Python)
Lightweight socket server injected via ConfigMap. Loads user function, executes handler logic, returns results or errors.

**Python 3.7+ compatibility**: Runtime uses backward-compatible type hints (`typing.Dict`/`List`) to support older AI model frameworks and legacy inference servers.

**Source of truth**: `src/asya-runtime/asya_runtime.py` (single file, no dependencies)

**Symlinks for embedding**:
- `src/asya-operator/internal/controller/runtime_symlink/asya_runtime.py` ‚Üí Operator reads and injects into ConfigMap
- `testing/integration/operator/testdata/runtime_symlink/asya_runtime.py` ‚Üí Integration tests use same runtime

**How it's deployed**: Operator reads `asya_runtime.py`  at runtime (via `ASYA_RUNTIME_SCRIPT_PATH` or default `/runtime/asya_runtime.py`), stores content in ConfigMap, then mounts ConfigMap into actor pods at `/opt/asya/asya_runtime.py`.

**IMPORTANT**: When modifying `src/asya-runtime/asya_runtime.py`, the symlinks automatically reflect changes. No manual sync needed - symlinks point to the source file.

**Handler Types**:
- **Function handler**: `ASYA_HANDLER=module.function` ‚Üí Direct function call (simple, stateless handlers)
- **Class handler**: `ASYA_HANDLER=module.Class.method` ‚Üí Stateful handlers with initialization (model loading, preprocessing setup)

**Handler Modes** (via `ASYA_HANDLER_MODE`):
- **`payload`** (default): Handler receives only payload, headers/route preserved automatically
  ```python
  # Function handler: ASYA_HANDLER=my_module.process
  def process(payload: dict) -> dict:
      return {"result": ...}  # Single value or list for fan-out

  # Class handler: ASYA_HANDLER=my_module.Processor.process
  class Processor:
      def __init__(self, model_path: str = "/models/default"):
          self.model = load_model(model_path)  # Init once

      def process(self, payload: dict) -> dict:
          return {"result": self.model.predict(payload)}
  ```

- **`envelope`**: Handler receives full envelope structure `{id, route, headers, payload}`
  ```python
  # Function handler: ASYA_HANDLER=my_module.process
  def process(envelope: dict) -> dict:
      return {"payload": ..., "route": envelope["route"], "headers": envelope.get("headers", {})}

  # Class handler: ASYA_HANDLER=my_module.EnvelopeProcessor.process
  class EnvelopeProcessor:
      def __init__(self):
          self.preprocessor = load_preprocessor()

      def process(self, envelope: dict) -> dict:
          data = self.preprocessor(envelope["payload"])
          return {"payload": data, "route": envelope["route"], "headers": envelope.get("headers", {})}
  ```

### asya-crew (Python)
System actors with reserved roles: `happy-end` (persist results to S3), `error-end` (retry with exponential backoff, DLQ handling). Both report final status to gateway.

### asya-operator (Go/Kubebuilder)
Watches AsyncActor CRDs, injects sidecars, creates workloads (Deployment/StatefulSet), configures KEDA autoscaling. Source of truth: `src/asya-operator/config/crd/`

### asya-testing (Python)
Shared testing utilities and fixtures used across component, integration, and e2e tests. Provides common assertions, mock helpers, and test data builders.

### asya-cli (Python)
Command-line tools for debugging and operating the Asyaüé≠ framework:
- **asya mcp call**: Call MCP tools on asya-gateway
- **asya mcp list**: List available tools
- **asya mcp show**: Show tool configuration
- **asya mcp status**: Check envelope status
- **asya mcp stream**: Stream envelope updates
- **asya mcp port-forward**: Quick kubectl port-forward helper for accessing asya-gateway

## Development Workflow

**Setup**: `make setup` (install uv, pre-commit hooks, sync Go deps)

**Building**: `make build` (all components), `make build-images` (Docker images), `make build-go` (Go only)

**Testing**:
```bash
# Run all unit tests (Go + Python)
make test-unit

# Run unit tests for specific components
make -C src/asya-sidecar test-unit    # Go sidecar unit tests only
make -C src/asya-gateway test-unit    # Go gateway unit tests only
make -C src/asya-runtime test-unit    # Python runtime unit tests only

# Run all component tests
make test-component

# Run all integration tests (requires Docker Compose)
make test-integration

# Clean up integration test Docker resources
make clean-integration

# Run specific integration test suites
make -C testing/integration/sidecar-runtime test   # Sidecar ‚Üî Runtime
make -C testing/integration/gateway-actors test    # Gateway ‚Üî Actors

# Run all tests (unit + integration)
make test

# Run end-to-end tests (requires Kind cluster)
make test-e2e
# or:
# cd testing/e2e
# export PROFILE=sqs-s3  # for now, testing e2e only sqs-s3
# make up
# make trigger-tests 2>&1 | tee /tmp/tests.txt
```

**Code Coverage**:

The project uses **octocov** for code coverage reporting - a fully open-source solution that runs in GitHub Actions without external services.

**Linting**: `make lint` (auto-fix enabled via pre-commit)

Linting tools with auto-fix capabilities:
- ‚úÖ **Auto-fix enabled**: yamlfmt, shfmt, prettier (JSON), taplo (TOML), ruff, go fmt, golangci-lint
- ‚ùå **Validation only**: yamllint, shellcheck, mypy, bandit, vulture, actionlint, helm-lint

**Quick fix**: Just run `make lint` - most formatting issues are automatically fixed. Only validation-only tools (security, type checking) require manual fixes.

**Cleaning**: `make clean` (remove build artifacts), `make clean-integration`, `make clean-e2e` (remove Docker/Kind resources)

## Test Hierarchy

Tests are organized by scope and dependencies with **strict isolation rules**:

1. **Unit tests** (`make test-unit`): Fast, no external dependencies
   - **Location**: Embedded in `src/{component}/tests/`
   - Test individual functions, classes, modules
   - No Docker, RabbitMQ, or K8s required

2. **Component tests** (`make test-component`): Single component with minimal infrastructure
   - **Location**: `testing/component/{component}/`
   - Uses Docker Compose for minimal infrastructure (RabbitMQ, PostgreSQL, etc.)
   - Tests single component behavior in isolation
   - **Structure**: Component-specific, may use `compose/`, `profiles/`, `tests/`, `Makefile`

3. **Integration tests** (`make test-integration`): Multiple components together
   - **Location**: `testing/integration/{suite}/`
   - Uses Docker Compose for multi-component scenarios
   - Tests sidecar ‚Üî runtime ‚Üî gateway interactions
   - **Structure**: `compose/`, `profiles/`, `tests/`, `Makefile`

4. **End-to-end tests** (`make test-e2e`): Full stack in Kind cluster
   - **Location**: `testing/e2e/`
   - Full Kubernetes deployment with operator, gateway, actors
   - Tests user scenarios and autoscaling

### E2E Test Fixing Strategy

**CRITICAL**: Kind cluster recreation is expensive (15-25 minutes). Avoid `make down` / `make up` cycles during debugging.

**Fast iteration workflow** (avoid full redeployment):
1. Patch code in `src/{component}/`
2. Rebuild images: `make build-images`
3. Load images to Kind: `kind load docker-image {image}:{tag} --name asya-e2e-{profile}`
4. Upgrade only affected deployments/Helm charts:
   - Operator: `helm upgrade -n asya-system asya-operator deploy/helm-charts/asya-operator/`
   - Gateway: `helm upgrade -n asya-e2e asya-gateway deploy/helm-charts/asya-gateway/`
   - Crew: `helm upgrade -n asya-e2e asya-crew deploy/helm-charts/asya-crew/`
5. Restart pods if needed: `kubectl rollout restart -n {namespace} deployment/{name}`

**Test execution**:
- Run with fail-fast: `make trigger-tests PYTEST_OPTS="-vv -x" PROFILE="sqs-s3" 2>&1 | tee /tmp/tests.txt`
- Fix one test at a time: `-x` flag stops on first failure
- Monitor frequently: Check test output every 1 minute, do NOT sleep long
- Log to file: Always use `tee` to capture full output for analysis

### Testing Infrastructure Rules

**Critical rules for all tests:**

1. **No port-forwarding in unit/component/integration tests**
   - Unit tests MUST mock third-party services
   - Component/Integration test code MUST run inside Docker Compose, services communicate via Docker networks
   - Only E2E tests can use `kubectl port-forward`

2. **Prefer Docker Compose over Kind**
   - Use Docker Compose for integration tests when possible
   - Use Kind only for E2E tests requiring Kubernetes features (operator, KEDA, CRDs)

3. **Shared infrastructure**
   - Reusable Docker Compose files in `testing/shared/compose/`
   - Third-party configs in `testing/shared/compose/configs/`
   - Environment files in `testing/shared/compose/envs/`

### Test Structure (Component/Integration)

```
testing/{level}/{suite}/
‚îú‚îÄ‚îÄ Makefile                       # Test targets: test, test-one, cov, down, clean
‚îú‚îÄ‚îÄ compose/                       # Local service definitions
‚îÇ   ‚îú‚îÄ‚îÄ tester.yml                 # Test runner service
‚îÇ   ‚îî‚îÄ‚îÄ testing-actors.yml         # Suite-specific actors
‚îú‚îÄ‚îÄ profiles/                      # Test profiles (transport/storage combinations)
‚îÇ   ‚îú‚îÄ‚îÄ .env.sqs                   # ASYA_TRANSPORT=sqs
‚îÇ   ‚îú‚îÄ‚îÄ .env.rabbitmq              # ASYA_TRANSPORT=rabbitmq
‚îÇ   ‚îú‚îÄ‚îÄ sqs.yml                    # Profile: SQS transport
‚îÇ   ‚îî‚îÄ‚îÄ rabbitmq.yml               # Profile: RabbitMQ transport
‚îî‚îÄ‚îÄ tests/                         # Pytest test files
```

**Makefile patterns:**
- **Separate Docker Compose projects per transport**: `COMPOSE_PROJECT := {suite}-$(ASYA_TRANSPORT)`
- **Required environment variables**: `ASYA_TRANSPORT`, `ASYA_HANDLER_MODE`, `ASYA_STORAGE`
- **Coverage directory**: `.coverage/{test-suite}/{transport}/cov.json`
- **Standard targets**: `test`, `test-one`, `cov`, `down`, `clean`

**Dynamic parametrization** via environment variables:
```bash
# Component test
make test-one ASYA_TRANSPORT=sqs

# Integration test with multiple variables
make test-one ASYA_TRANSPORT=rabbitmq ASYA_STORAGE=minio ASYA_HANDLER_MODE=envelope
```

**Profile assembly** uses Docker Compose `include:` directive:
```yaml
# profiles/rabbitmq.yml
include:
  - path: ../../../shared/compose/rabbitmq.yml  # Shared infrastructure
services:
  tester:
    extends:
      file: ../compose/tester.yml
      service: tester
    env_file:
      - ../../../shared/compose/envs/.env.${ASYA_TRANSPORT}  # ‚Üí .env.rabbitmq
```

See CONTRIBUTING.md for complete testing documentation.

## Envelope Protocol

```json
{
  "id": "<envelope-id>",
  "parent_id": "<original-envelope-id>",  // optional, for fanout tracking
  "route": {"actors": ["q1", "q2"], "current": 0},
  "headers": {"trace_id": "...", "priority": "high"},  // optional routing metadata
  "payload": <arbitrary JSON>
}
```

**Fields**:
- `id`: Unique envelope identifier
- `parent_id` (optional): Original envelope ID for fanout children (see docs/architecture/protocols/actor-actor.md)
- `route`: Routing information with actor names and current index
- `headers` (optional): Routing-specific metadata (trace IDs, priorities, etc.)
- `payload`: Arbitrary JSON data processed by actors

Runtime (not sidecar!) increments `route.current` after processing.

**Automatic end routing** (NEVER configure explicitly):
- When `route.current` reaches end of `actors` array (or when runtime returned empty list) ‚Üí sidecar routes to `happy-end` queue automatically
- When errors occur in runtime ‚Üí sidecar acks the message and routes to `error-end` queue automatically
- When errors occur in sidecar ‚Üí sidecar nacks the message and it's automatically sent to DLQ (configured by the queue)
- **IMPORTANT**: Never include `happy-end` or `error-end` in route configurations - they are managed by the sidecar

**Route Modification Rules** (for envelope mode handlers):

Handlers can modify routes dynamically but **MUST preserve already-processed steps**:

‚úÖ **Allowed**:
- Add future steps: `["a","b","c"]` ‚Üí `["a","b","c","d","e"]` (at current=0)
- Replace future steps: `["a","b","c"]` ‚Üí `["a","x","y"]` (at current=0, replaces b,c with x,y)

‚ùå **Forbidden** (runtime will reject with `processing_error`):
- Erase processed steps: `["a","b","c"]` ‚Üí `["c"]` at current=2 (erases "a","b")
- Modify processed actor names: `["a","b","c"]` ‚Üí `["a-new","b","c"]` at current=1
- Change current position: Cannot change which actor `route.current` points to

**Validation**: Runtime validates that `route.actors[0:current+1]` remains unchanged from input to output.

## Transport Configuration

**Centralized transport management**: Transport configurations (RabbitMQ, SQS) are defined at operator installation time in `deploy/helm-charts/asya-operator/values.yaml`, not in individual AsyncActor CRDs.

**Actor transport reference**: AsyncActors reference a transport by name:
```yaml
spec:
  transport: rabbitmq  # Just the name, not full config
```

**Operator validates**: Operator validates that the referenced transport exists and is enabled before creating the actor workload.

### Queue Management

**IMPORTANT**: All message queues are automatically managed by the asya-operator when transport is enabled.

**Queue naming convention**: `asya-{namespace}-{actor_name}`
- Example: Actor `text-analyzer` in namespace `prod` ‚Üí Queue `asya-prod-text-analyzer`
- Example: Actor `image-processor` in namespace `dev` ‚Üí Queue `asya-dev-image-processor`
- System actors: `asya-{namespace}-happy-end`, `asya-{namespace}-error-end`
- Enables multi-namespace deployments with actors of the same name in different namespaces

**IAM granularity**: The `asya-` prefix enables fine-grained IAM policies:
```json
{
  "Effect": "Allow",
  "Action": ["sqs:SendMessage", "sqs:ReceiveMessage"],
  "Resource": "arn:aws:sqs:*:*:asya-*"
}
```

**Lifecycle**: Queues are created/deleted automatically by the operator during AsyncActor reconciliation. Never create queues manually.

**Example operator config**:
```yaml
transports:
  rabbitmq:
    enabled: true
    type: rabbitmq
    config:
      host: rabbitmq.default.svc.cluster.local
      port: 5672
      username: guest
      passwordSecretRef:
        name: rabbitmq-secret
        key: password
```

### Transport Credentials

**Credential Separation**: Operator uses two types of credentials:

1. **Operator Credentials** (in `asya-system` namespace)
   - Used by: Operator for queue management (create/delete/configure)
   - Secret: Configured in transport config (`sqs-secret`, `rabbitmq-secret`)
   - Permissions: Admin-level queue operations

2. **Actor Credentials** (in actor's namespace)
   - Used by: Sidecar containers for message operations (send/receive/delete)
   - Secret: `<actor-name>-transport-creds` (auto-created by operator)
   - Permissions: Message operations only
   - Ownership: AsyncActor CRD (auto-deleted when AsyncActor is deleted)

**Secret Lifecycle**:
- Operator reads credentials from its own namespace (`asya-system`)
- Operator creates actor-specific secret in actor's namespace
- Secret has owner reference to AsyncActor (automatic cleanup)
- Sidecar references actor-specific secret (not operator secret)

## Key Deployment Facts

**Operator chart** (`deploy/helm-charts/asya-operator/`): Deploys only the operator pod. Does NOT deploy CRDs, actors, or KEDA.

**CRD installation**: `kubectl apply -f src/asya-operator/config/crd/` (source of truth, regenerate with `make manifests` in `src/asya-operator/`)

**E2E deployment**: `make test-e2e` deploys full stack to Kind cluster, runs tests, and cleans up automatically

**E2E tests**: Validate MCP tools, SSE streaming, multi-actor pipelines, error handling, autoscaling

## AI Automation Policies

### Bitnami Policy

**NEVER use Bitnami Helm charts or images.** Bitnami has removed many container images from Docker Hub, causing deployment failures.

**Required**:
- Use official upstream images (e.g., `rabbitmq:3.13-management`, `postgres:15-alpine`, `minio/minio:latest`)
- Use simple Kubernetes manifests instead of complex Helm charts for infrastructure
- Store manifests in `testing/e2e/manifests/`

**Examples**:
```yaml
# Good - official image
image: minio/minio:latest

# Bad - Bitnami chart
chart: oci://registry-1.docker.io/bitnamicharts/minio
```

### Command Execution Hierarchy
1. **Prefer**: `make <target>` (e.g., `make test`, `make build`)
2. **Last resort**: Direct commands only if no Makefile target exists

**Rule**: Add new Makefile targets instead of repeating raw commands. See `.claude/settings.local.json` for automation config.

### Documentation Policy

**NEVER proactively create documentation files** (*.md, README.md, design docs) unless explicitly requested by the user.

**Exceptions**:
- User explicitly asks for documentation
- Required by user story/task
- Updating existing documentation to reflect code changes

**Rationale**: Documentation should be created intentionally, not as a side-effect of every code change. Over-documentation creates maintenance burden.

### Code Comment Policy

**Never use transitional comments** that reference previous code state ("no need to", "increased from", "instead of").

**Good**: Explain what/why the code does
```python
poll_interval = 0.1  # 100ms polling interval
```

**Bad**: Reference how it differs from before
```python
# Increased timeout for multi-actor processing
result = ...
```

### Defaults for Environment Variables

**NEVER add defaults to environment variables in code or docker-compose files.** Follow fail-fast strategy.

**Required**: All required environment variables MUST be passed from Makefile to docker-compose explicitly. If a variable is missing, docker-compose should fail immediately.

**Good** (testing/integration/sidecar-runtime/compose/tester.yml):
```yaml
volumes:
- ${COVERAGE_DIR}:/app/.coverage:rw
- ${COVERAGERC}:/app/.coveragerc:ro
```

**Bad**: Adding defaults that hide missing configuration
```yaml
volumes:
- ${COVERAGE_DIR:-.coverage}:/app/.coverage:rw  # Don't do this
```

**Rationale**: Defaults hide configuration errors. Better to fail fast when required variables are missing than silently use wrong paths.

### Sleep Policy

**Never use `time.Sleep`/`time.sleep` in production code.** Sleep makes tests flaky and hides bugs.

**Only allowed in tests**: Polling loops, test simulations, timeout testing. **Must have inline comment** explaining purpose.

**Good**:
```python
time.sleep(poll_interval)  # Poll RabbitMQ API for new messages
```

**Bad**: No comment, or used in production code.

**Alternatives**: Channels/wait groups (Go), blocking operations with timeouts, health check endpoints.

### Emoji Policy

**Strict emoji restrictions** to maintain professional codebase:

**Documentation files** (.md) - ONLY basic status emojis allowed:
- ‚úÖ (check mark) - yes/supported/allowed
- ‚ùå (cross mark) - no/unsupported/forbidden
- ‚ö†Ô∏è (warning) - warnings/caveats
- üü¢ (green circle) - good/easy
- üü° (yellow circle) - medium quality/medium difficulty
- üî¥ (red circle) - bad/hard

**Code files** (.py, .go, .sh, .yaml) - NO emojis allowed:

Use text status indicators instead:
```bash
echo "[+] Success message"
echo "[-] Failure message"
echo "[!] Warning/attention message"
echo "[.] In progress message"
```

**Test data** - Unicode test strings allowed, but NO decorative emojis.

**Examples**:
```python
# Bad - emoji in logger
logger.info("‚úì Test passed")

# Good - text marker
logger.info("[+] Test passed")
```

```yaml
# Bad - emoji in comment
# ‚úì Working deployment

# Good - text marker
# - Working deployment
```
